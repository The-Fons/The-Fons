<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR/VR Genealogy Tree</title>
    <!--
        Dear Claude, please make me 
        a webpage to show a sample genealogy tree in regular 2D desktop mode for the artifact viewer or in AR or VR selectable by buttons, for use on a Quest3.
        make sure the ar/vr object is in front of the viewer in all three modes.
        when selecting a person the persons info should be shown on screen in desktop mode and in AR/VR mode visible in view. 

        fixed (thanks): 
        - the desktop mode shows no persons or tree, earlier versions did,
        - the AR and VR buttons switch mode but do not show anything
        issues:
        - the controllers dont work in AR or VR mode.
        - handtracking does not work
        new features:
        - in genealogy usually a family object is used linking the father and the mother, also the children are linked to this object. (to avoid links crossing) 
        -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 15px;
        }
        
        .control-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 1);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-height: 200px;
            overflow-y: auto;
        }
        
        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
        }

        #personInfo {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            display: none;
            max-width: 300px;
            text-align: center;
        }

        #personInfo h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }

        #personInfo p {
            margin: 5px 0;
        }

        #closeInfo {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <button id="arBtn" class="control-btn">Enter AR</button>
            <button id="vrBtn" class="control-btn">Enter VR</button>
            <button id="resetBtn" class="control-btn">Reset View</button>
        </div>
        
        <div id="status">Desktop Mode</div>
        
        <div id="info">
            <h3>Genealogy Tree Explorer</h3>
            <p>Desktop: Click and drag to rotate, scroll to zoom, click on family members to see their info</p>
            <p>AR/VR: Use hand tracking or controllers to interact with family members</p>
        </div>

        <div id="personInfo">
            <h3 id="personName"></h3>
            <p id="personBirth"></p>
            <p id="personDeath"></p>
            <p id="personGeneration"></p>
            <button id="closeInfo">Close</button>
        </div>
    </div>

    <script>
        let scene, camera, renderer;
        let familyTree = [];
        let currentMode = 'desktop';
        let xrSession = null;
        let raycaster, mouse;
        let treeGroup = null;
        
        // Sample family data
        const familyData = [
            { name: "Great Grandpa John", generation: 0, position: [0, 3, 0], birth: "1920", death: "1995" },
            { name: "Great Grandma Mary", generation: 0, position: [2, 3, 0], birth: "1922", death: "1998" },
            { name: "Grandpa Robert", generation: 1, position: [-2, 1.5, 0], birth: "1945", death: "2010" },
            { name: "Grandma Susan", generation: 1, position: [0, 1.5, 0], birth: "1947", death: "" },
            { name: "Grandpa William", generation: 1, position: [2, 1.5, 0], birth: "1943", death: "2005" },
            { name: "Grandma Patricia", generation: 1, position: [4, 1.5, 0], birth: "1948", death: "" },
            { name: "Dad Michael", generation: 2, position: [-1, 0, 0], birth: "1970", death: "" },
            { name: "Mom Jennifer", generation: 2, position: [1, 0, 0], birth: "1972", death: "" },
            { name: "Uncle David", generation: 2, position: [3, 0, 0], birth: "1968", death: "" },
            { name: "Aunt Lisa", generation: 2, position: [5, 0, 0], birth: "1975", death: "" },
            { name: "You", generation: 3, position: [0, -1.5, 0], birth: "1995", death: "" },
            { name: "Sister Emily", generation: 3, position: [2, -1.5, 0], birth: "1998", death: "" },
            { name: "Cousin Jake", generation: 3, position: [4, -1.5, 0], birth: "1993", death: "" }
        ];

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Camera - positioned to see the tree better
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 10);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create family tree
            createFamilyTree();
            
            setupMouseControls();
            setupEventListeners();
            checkXRSupport();
            
            animate();
        }

        function setupMouseControls() {
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isMouseDown && currentMode === 'desktop') {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    if (treeGroup) {
                        treeGroup.rotation.y += deltaX * 0.01;
                        treeGroup.rotation.x += deltaY * 0.01;
                    }
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                if (currentMode === 'desktop') {
                    camera.position.z += e.deltaY * 0.01;
                    camera.position.z = Math.max(5, Math.min(20, camera.position.z));
                }
            });

            // Click to select person
            renderer.domElement.addEventListener('click', (e) => {
                if (currentMode === 'desktop' && !isMouseDown) {
                    onPersonClick(e);
                }
            });
        }

        function setupEventListeners() {
            document.getElementById('arBtn').addEventListener('click', enterAR);
            document.getElementById('vrBtn').addEventListener('click', enterVR);
            document.getElementById('resetBtn').addEventListener('click', resetView);
            document.getElementById('closeInfo').addEventListener('click', () => {
                document.getElementById('personInfo').style.display = 'none';
            });
            
            window.addEventListener('resize', onWindowResize);
        }

        function onPersonClick(event) {
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const clickableObjects = familyTree.map(item => item.card);
            const intersects = raycaster.intersectObjects(clickableObjects);

            if (intersects.length > 0) {
                const selectedObject = intersects[0].object;
                showPersonInfo(selectedObject.userData);
            }
        }

        function showPersonInfo(person) {
            document.getElementById('personName').textContent = person.name;
            document.getElementById('personBirth').textContent = `Born: ${person.birth}`;
            document.getElementById('personDeath').textContent = person.death ? `Died: ${person.death}` : 'Still alive';
            document.getElementById('personGeneration').textContent = `Generation: ${person.generation + 1}`;
            document.getElementById('personInfo').style.display = 'block';
        }
        
        function createFamilyTree() {
            // Create a group to hold all tree elements
            treeGroup = new THREE.Group();
            scene.add(treeGroup);
            
            const cardGeometry = new THREE.PlaneGeometry(1.8, 1.2);
            
            familyData.forEach((person, index) => {
                // Create card background with rounded corners effect
                const cardMaterial = new THREE.MeshLambertMaterial({ 
                    color: getGenerationColor(person.generation),
                    transparent: true,
                    opacity: 0.9
                });
                
                const card = new THREE.Mesh(cardGeometry, cardMaterial);
                card.position.set(...person.position);
                card.userData = person;
                treeGroup.add(card);
                
                // Create text canvas with better formatting
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 256;
                
                // Background
                context.fillStyle = 'rgba(255, 255, 255, 0.95)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Border
                context.strokeStyle = '#333';
                context.lineWidth = 4;
                context.strokeRect(0, 0, canvas.width, canvas.height);
                
                // Text
                context.fillStyle = '#333';
                context.font = 'bold 28px Arial';
                context.textAlign = 'center';
                context.fillText(person.name, canvas.width / 2, 60);
                
                context.font = '20px Arial';
                context.fillText(`Born: ${person.birth}`, canvas.width / 2, 110);
                if (person.death) {
                    context.fillText(`Died: ${person.death}`, canvas.width / 2, 140);
                } else {
                    context.fillStyle = '#27ae60';
                    context.fillText('Still alive', canvas.width / 2, 140);
                }
                
                context.fillStyle = '#7f8c8d';
                context.font = '16px Arial';
                context.fillText(`Generation ${person.generation + 1}`, canvas.width / 2, 180);
                
                // Create text texture
                const textTexture = new THREE.CanvasTexture(canvas);
                const textMaterial = new THREE.MeshBasicMaterial({ 
                    map: textTexture,
                    transparent: true
                });
                
                const textMesh = new THREE.Mesh(cardGeometry, textMaterial);
                textMesh.position.set(person.position[0], person.position[1], person.position[2] + 0.01);
                textMesh.userData = person;
                treeGroup.add(textMesh);
                
                familyTree.push({ card, textMesh, person });
            });
            
            // Add connecting lines
            createConnectionLines();
        }
        
        function createConnectionLines() {
            // Create simple family connections
            const connections = [
                // Great grandparents to grandparents
                [0, 2], [0, 3], [1, 2], [1, 3], // Great Grandpa John & Mary to Robert & Susan
                [0, 4], [0, 5], [1, 4], [1, 5], // Great Grandpa John & Mary to William & Patricia
                
                // Grandparents to parents
                [2, 6], [3, 6], // Robert & Susan to Michael
                [3, 7], [2, 7], // Robert & Susan to Jennifer
                [4, 8], [5, 8], // William & Patricia to David
                [4, 9], [5, 9], // William & Patricia to Lisa
                
                // Parents to children
                [6, 10], [7, 10], // Michael & Jennifer to You
                [6, 11], [7, 11], // Michael & Jennifer to Emily
                [8, 12], [9, 12], // David & Lisa to Jake
            ];

            connections.forEach(([fromIndex, toIndex]) => {
                const fromPerson = familyData[fromIndex];
                const toPerson = familyData[toIndex];
                
                const points = [
                    new THREE.Vector3(...fromPerson.position),
                    new THREE.Vector3(...toPerson.position)
                ];
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x8B4513,
                    linewidth: 2
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                treeGroup.add(line);
            });
        }
        
        function getGenerationColor(generation) {
            const colors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFFA07A];
            return colors[generation % colors.length];
        }
        
        async function checkXRSupport() {
            if ('xr' in navigator) {
                try {
                    const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
                    const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
                    
                    document.getElementById('arBtn').disabled = !arSupported;
                    document.getElementById('vrBtn').disabled = !vrSupported;
                    
                    if (!arSupported && !vrSupported) {
                        document.getElementById('info').innerHTML += '<p style="color: yellow;">XR not supported on this device</p>';
                    }
                } catch (error) {
                    console.log('XR support check failed:', error);
                    document.getElementById('arBtn').disabled = true;
                    document.getElementById('vrBtn').disabled = true;
                }
            } else {
                document.getElementById('arBtn').disabled = true;
                document.getElementById('vrBtn').disabled = true;
                document.getElementById('info').innerHTML += '<p style="color: yellow;">WebXR not available</p>';
            }
        }
        
        async function enterAR() {
            try {
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local-floor'],
                    optionalFeatures: ['hand-tracking', 'hit-test']
                });
                
                await renderer.xr.setSession(xrSession);
                currentMode = 'AR';
                document.getElementById('status').textContent = 'AR Mode';
                
                // Position tree for AR
                if (treeGroup) {
                    treeGroup.position.set(0, -1, -2);
                    treeGroup.scale.set(0.4, 0.4, 0.4);
                }
                
                // Make background transparent for AR
                scene.background = null;
                
                xrSession.addEventListener('end', () => {
                    exitXR();
                });
                
            } catch (error) {
                console.error('Failed to enter AR:', error);
                alert('Failed to enter AR mode. Make sure you\'re on a compatible device.');
            }
        }
        
        async function enterVR() {
            try {
                xrSession = await navigator.xr.requestSession('immersive-vr', {
                    requiredFeatures: ['local-floor'],
                    optionalFeatures: ['hand-tracking']
                });
                
                await renderer.xr.setSession(xrSession);
                currentMode = 'VR';
                document.getElementById('status').textContent = 'VR Mode';
                
                // Position tree for VR
                if (treeGroup) {
                    treeGroup.position.set(0, 0, -4);
                    treeGroup.scale.set(0.6, 0.6, 0.6);
                }
                
                // Dark background for VR
                scene.background = new THREE.Color(0x1a1a2e);
                
                xrSession.addEventListener('end', () => {
                    exitXR();
                });
                
            } catch (error) {
                console.error('Failed to enter VR:', error);
                alert('Failed to enter VR mode. Make sure you\'re on a compatible device.');
            }
        }

        function exitXR() {
            currentMode = 'desktop';
            document.getElementById('status').textContent = 'Desktop Mode';
            
            // Reset tree position and scale
            if (treeGroup) {
                treeGroup.position.set(0, 0, 0);
                treeGroup.scale.set(1, 1, 1);
                treeGroup.rotation.set(0, 0, 0);
            }
            
            // Restore background
            scene.background = new THREE.Color(0x87CEEB);
            
            xrSession = null;
        }
        
        function resetView() {
            if (currentMode === 'desktop' && treeGroup) {
                treeGroup.position.set(0, 0, 0);
                treeGroup.rotation.set(0, 0, 0);
                treeGroup.scale.set(1, 1, 1);
                camera.position.set(0, 0, 10);
            }
            
            document.getElementById('personInfo').style.display = 'none';
        }
        
        function animate() {
            renderer.setAnimationLoop(() => {
                // Gentle floating animation for cards in desktop mode
                if (currentMode === 'desktop' && treeGroup) {
                    familyTree.forEach((item, index) => {
                        const time = Date.now() * 0.001;
                        const offset = index * 0.5;
                        item.card.position.y = item.person.position[1] + Math.sin(time + offset) * 0.05;
                        item.textMesh.position.y = item.card.position.y + 0.01;
                    });
                }
                
                renderer.render(scene, camera);
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize the application
        init();
    </script>
</body>
</html>